#!/usr/bin/env python3
"""
Factory Boy factory template for {model_name}

This file was automatically generated by Claude Code Hooks to support TDD
and ensure consistent test data generation following DRY principles.
"""

import factory
from factory import Faker, Sequence, Trait, LazyFunction, LazyAttribute
from datetime import datetime, date
import random

# SQLAlchemy imports (if needed)
try:
    from sqlalchemy.orm import Session
    from src.database import get_test_session
except ImportError:
    Session = None
    get_test_session = None

# Import the model
try:
    from {model_import_path} import {model_name}
except ImportError:
    {model_name} = None


class {model_name}Factory(factory.Factory):
    """Factory for generating {model_name} test instances."""
    
    class Meta:
        model = {model_name}
        # Uncomment below for SQLAlchemy models
        # sqlalchemy_session = Session
        # sqlalchemy_session_persistence = 'commit'
    
    # TODO: Define factory fields based on your model
    # Remove this comment and implement actual fields
    
    # Example fields - replace with actual model fields:
    
    # Primary key (usually auto-generated)
    # id = Sequence(lambda n: n)
    
    # String fields
    # name = Faker('name')
    # email = Faker('email') 
    # description = Faker('text', max_nb_chars=200)
    
    # Numeric fields
    # amount = Faker('pyfloat', positive=True, max_value=1000, right_digits=2)
    # count = Faker('pyint', min_value=1, max_value=100)
    
    # Boolean fields
    # is_active = Faker('boolean')
    # is_verified = True  # or Faker('boolean')
    
    # Date/time fields
    # created_at = Faker('date_time')
    # updated_at = LazyFunction(datetime.now)
    # birth_date = Faker('date_between', start_date='-30y', end_date='-18y')
    
    # Choice fields
    # status = Faker('random_element', elements=['active', 'inactive', 'pending'])
    # category = factory.Iterator(['type1', 'type2', 'type3'])
    
    # Foreign key relationships (for SQLAlchemy models)
    # user_id = factory.SubFactory('tests.factories.UserFactory')
    # parent = factory.SubFactory('tests.factories.ParentFactory')
    
    # Computed fields
    # full_name = LazyAttribute(lambda obj: f"{{obj.first_name}} {{obj.last_name}}")
    
    # HSA-specific example fields (if applicable):
    coverage_type = factory.Iterator(['self-only', 'family'])
    ytd_contribution = Faker('pyfloat', positive=True, max_value=8000, right_digits=2)
    is_55_plus = Faker('boolean', chance_of_getting_true=30)  # 30% chance
    remaining_pay_periods = Faker('pyint', min_value=1, max_value=26)
    annual_limit = LazyAttribute(
        lambda obj: 8550.0 if obj.coverage_type == 'family' else 4300.0
    )
    catch_up_limit = LazyAttribute(
        lambda obj: 1000.0 if obj.is_55_plus else 0.0
    )
    
    class Params:
        """Traits for creating specific test scenarios."""
        
        # Boolean trait examples
        active = Trait(is_active=True)
        inactive = Trait(is_active=False)
        verified = Trait(is_verified=True)
        unverified = Trait(is_verified=False)
        
        # HSA-specific traits
        family_coverage = Trait(
            coverage_type='family',
            annual_limit=8550.0
        )
        
        self_only_coverage = Trait(
            coverage_type='self-only', 
            annual_limit=4300.0
        )
        
        eligible_for_catch_up = Trait(
            is_55_plus=True,
            catch_up_limit=1000.0
        )
        
        near_contribution_limit = Trait(
            ytd_contribution=LazyAttribute(
                lambda obj: obj.annual_limit - 500.0
            )
        )
        
        over_contribution_limit = Trait(
            ytd_contribution=LazyAttribute(
                lambda obj: obj.annual_limit + 1000.0
            )
        )
        
        # Scenario-based traits
        new_user = Trait(
            ytd_contribution=0.0,
            remaining_pay_periods=26
        )
        
        mid_year_user = Trait(
            ytd_contribution=LazyAttribute(
                lambda obj: obj.annual_limit * 0.5
            ),
            remaining_pay_periods=13
        )
        
        end_of_year_user = Trait(
            remaining_pay_periods=Faker('pyint', min_value=1, max_value=3)
        )


# Specialized factories for different test scenarios
class New{model_name}Factory({model_name}Factory):
    """Factory for new {model_name} instances (minimal data)."""
    
    # Override fields for "new" scenario
    # created_at = LazyFunction(datetime.now)
    # is_active = True
    pass


class Complete{model_name}Factory({model_name}Factory):
    """Factory for {model_name} instances with all fields populated."""
    
    # Override to ensure all optional fields are populated
    # description = Faker('text', max_nb_chars=500)
    # tags = factory.List([Faker('word') for _ in range(3)])
    pass


# Helper functions for complex factory scenarios
def create_test_scenario(scenario_name: str, count: int = 1, **kwargs):
    """
    Create test data for specific scenarios.
    
    Args:
        scenario_name: Name of the test scenario
        count: Number of instances to create
        **kwargs: Additional factory parameters
        
    Returns:
        Single instance if count=1, list if count>1
    """
    scenarios = {{
        'new_user': New{model_name}Factory,
        'complete': Complete{model_name}Factory,
        'family_coverage': lambda: {model_name}Factory.create(family_coverage=True, **kwargs),
        'self_only_coverage': lambda: {model_name}Factory.create(self_only_coverage=True, **kwargs),
        'near_limit': lambda: {model_name}Factory.create(near_contribution_limit=True, **kwargs),
        'over_limit': lambda: {model_name}Factory.create(over_contribution_limit=True, **kwargs),
        'catch_up_eligible': lambda: {model_name}Factory.create(eligible_for_catch_up=True, **kwargs)
    }}
    
    if scenario_name not in scenarios:
        raise ValueError(f"Unknown scenario: {{scenario_name}}")
    
    factory_class = scenarios[scenario_name]
    
    if count == 1:
        return factory_class.create(**kwargs) if callable(factory_class) else factory_class()
    else:
        return [
            factory_class.create(**kwargs) if callable(factory_class) else factory_class()
            for _ in range(count)
        ]


def create_related_data():
    """Create related test data (for foreign key relationships)."""
    # Example of creating related data
    # user = UserFactory.create()
    # profile = {model_name}Factory.create(user=user)
    # return {{'user': user, 'profile': profile}}
    pass


# Test data builder for complex scenarios
class {model_name}TestDataBuilder:
    """Builder pattern for creating complex {model_name} test scenarios."""
    
    def __init__(self):
        self.data = {{}}
        self.factory = {model_name}Factory
    
    def with_coverage_type(self, coverage_type: str):
        """Set coverage type."""
        self.data['coverage_type'] = coverage_type
        return self
    
    def with_contribution(self, amount: float):
        """Set YTD contribution amount."""
        self.data['ytd_contribution'] = amount
        return self
    
    def with_age_55_plus(self, is_55_plus: bool = True):
        """Set age 55+ status."""
        self.data['is_55_plus'] = is_55_plus
        return self
    
    def with_pay_periods(self, periods: int):
        """Set remaining pay periods."""
        self.data['remaining_pay_periods'] = periods
        return self
    
    def build(self):
        """Build the factory instance (without saving to DB)."""
        return self.factory.build(**self.data)
    
    def create(self):
        """Create and save the factory instance."""
        return self.factory.create(**self.data)


# Usage examples (for documentation):
"""
Usage Examples:

# Basic usage
user = {model_name}Factory()
user_with_traits = {model_name}Factory(family_coverage=True, eligible_for_catch_up=True)

# Batch creation
users = {model_name}Factory.create_batch(5)
family_users = {model_name}Factory.create_batch(3, family_coverage=True)

# Using builder pattern
user = ({model_name}TestDataBuilder()
        .with_coverage_type('family')
        .with_contribution(5000.0)
        .with_age_55_plus(True)
        .create())

# Scenario-based creation
new_user = create_test_scenario('new_user')
near_limit_users = create_test_scenario('near_limit', count=3)

# For database tests
@pytest.fixture
def sample_user(test_db):
    return {model_name}Factory.create()

@pytest.fixture  
def family_user(test_db):
    return {model_name}Factory.create(family_coverage=True)
"""